(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{285:function(o,e,v){"use strict";v.r(e);var _=v(13),r=Object(_.a)({},(function(){var o=this,e=o._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[e("h1",{attrs:{id:"spring"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring"}},[o._v("#")]),o._v(" Spring")]),o._v(" "),e("h2",{attrs:{id:"ioc的流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ioc的流程"}},[o._v("#")]),o._v(" IOC的流程")]),o._v(" "),e("p",[e("strong",[o._v("流程")])]),o._v(" "),e("p",[o._v("1.先根据配置的资源路径（可以是"),e("code",[o._v("文件路径")]),o._v("、"),e("code",[o._v("url路径")]),o._v("）加载到"),e("code",[o._v("resource")]),o._v("中；")]),o._v(" "),e("p",[o._v("2.对"),e("code",[o._v("resource")]),o._v("中的资源文件进行解析，解析成"),e("code",[o._v("dom对象")]),o._v("；")]),o._v(" "),e("p",[o._v("3.对"),e("code",[o._v("dom对象")]),o._v("根据spring的xml语义进行解析，解析成"),e("code",[o._v("BeanDifinition")]),o._v("，并把BeanDifinition注册到ioc容器中。这个BeanDifinition就是对bean的定义、依赖描述，如classname、bean类型、init方法销毁方法；")]),o._v(" "),e("p",[o._v("4.根据"),e("code",[o._v("BeanDifinition")]),o._v("对bean进行实例化并进行依赖注入。这里有两种场景：a.在调用getBean时获取  b.在ioc初始化完成之后进行（lazy-init=false，默认true）")]),o._v(" "),e("p",[e("strong",[o._v("备注")]),o._v("：IOC可以使用BeanDifinition，也可以使用"),e("code",[o._v("@AutoWired")]),o._v("和"),e("code",[o._v("@Resource")]),o._v("，使用"),e("code",[o._v("@AutoWired")]),o._v("和"),e("code",[o._v("@Resource")]),o._v("是ioc容器通过反射找到属性的类型和名称，然后通过类型和名称在容器中查找bean，然后进行依赖注入。")]),o._v(" "),e("p",[e("code",[o._v("@AutoWired")]),o._v("：默认使用类型来查找，如果要使用名称可以配合Qualifier，允许为null可以设置required为false；")]),o._v(" "),e("p",[e("code",[o._v("@Resource")]),o._v("：先是用名称查找，如果找不到再用类型进行查找，如果指定了属性名就只会按名称来查找；")]),o._v(" "),e("p",[e("strong",[o._v("使用Java代码代替xml配置文件的原理")]),o._v("："),e("code",[o._v("@Configuration")]),o._v("注解的类就相当于一个XML文件，"),e("code",[o._v("@Bean")]),o._v("注解的方法就相当于xml里面的"),e("code",[o._v("<bean>")]),o._v("标签，"),e("code",[o._v("@Configuration")]),o._v("注解的类在扫描的时候会加载到"),e("code",[o._v("BeanDifinition")]),o._v("，然后"),e("code",[o._v("ConfigurationClassPostProcessor")]),o._v("后置处理器的enhanceConfigurationClasses()会对"),e("code",[o._v("@Configuration")]),o._v("标记的类进行增强：用cglib生成"),e("code",[o._v("@Configuration")]),o._v("注解类的代理类，代理类中对"),e("code",[o._v("@Bean")]),o._v("注解的方法进行了增强，在需要一个@Bean注解定义的bean时，会执行增强后的方法：在容器中查找有没有这个bean，有就直接返回，没有就调用原生方法生成一个bean再返回。从而达到替换xml的目的。")]),o._v(" "),e("h2",{attrs:{id:"springboot启动流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#springboot启动流程"}},[o._v("#")]),o._v(" springboot启动流程")]),o._v(" "),e("h2",{attrs:{id:"springboot自动配置学习"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#springboot自动配置学习"}},[o._v("#")]),o._v(" springboot自动配置学习")]),o._v(" "),e("p",[o._v("我们整合一些组件的时候，我们会引入一些"),e("code",[o._v("Starter")]),o._v("，这些starter的"),e("code",[o._v("pom")]),o._v("会引入该组件需要的依赖包，其中有一个依赖包是该组件的"),e("code",[o._v("AutoConfiure")]),o._v("包，这个包中有"),e("code",[o._v("meta-inf/spring.factories")]),o._v("文件，这个文件中有配置该组件的自动配置类；")]),o._v(" "),e("p",[o._v("springboot启动类中的"),e("code",[o._v("@EnableAutoConfig")]),o._v("注解会扫描所有依赖组件的"),e("code",[o._v("meta-inf/spring.factories")]),o._v("文件（@EnableAutoConfiguration注解内使用到了@import注解来完成导入配置的功能，而EnableAutoConfigurationImportSelector内部则是使用了SpringFactoriesLoader.loadFactoryNames方法进行扫描具有META-INF/spring.factories文件的jar包），加载文件中配置的自动配置类，这些配置类中通过"),e("code",[o._v("@Configuration")]),o._v(" 、"),e("code",[o._v("@Bean")]),o._v("注解加载组件的bean到ioc容器中，这些bean需要一些地址端口等配置，（通过PackageImport 可以扫描 AutoConfiure包中的bean），AutoConfiure包中的bean通过"),e("code",[o._v("@ConfigurationProperties")]),o._v("和"),e("code",[o._v("@EnableConfigurationProperties")]),o._v("加载配置文件中配置设置到组件bean的属性中，从而完成自动配置。")]),o._v(" "),e("h2",{attrs:{id:"spring-bean的生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-bean的生命周期"}},[o._v("#")]),o._v(" spring bean的生命周期")]),o._v(" "),e("h2",{attrs:{id:"spring-的aop实现方式理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-的aop实现方式理解"}},[o._v("#")]),o._v(" spring 的AOP实现方式理解")]),o._v(" "),e("p",[o._v("AOP的核心实现其实是在执行"),e("code",[o._v("BeanPostProcessor")]),o._v("的"),e("code",[o._v("postProcessorAfterInitialization()")]),o._v("里面实现的，整体流程如下：")]),o._v(" "),e("p",[o._v("首先启动类的"),e("code",[o._v("@EnableAspectJAutoProxy")]),o._v("注解会在容器中注入一个"),e("code",[o._v("AnnotationAwareAspectJAutoProxyCreator")]),o._v("的bean，这个bean是实现了BeanPostProcessor的，所以BeanPostProcessor的beanPostProcessorBeforeInstantiation会在拦截所有的bean，然后调用到"),e("code",[o._v("postProcessorAfterInitialization()")]),o._v("，这个方法中会调用"),e("code",[o._v("wrapIfNecessary()")]),o._v("，wrapIfNecessary()中会根据增强器表达式匹配增强器判断是否需要进行代理增强，需要增强就使用proxyFactory传入增强器和目标类，proxyFactory根据是否接口、是否配置cglib来判断使用jdk动态代理还是cglib代理生成代理类并返回，生成完成后再从容器中获取bean时获取到的就是被增强的代理类了。")]),o._v(" "),e("h2",{attrs:{id:"spring循环依赖解决方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring循环依赖解决方式"}},[o._v("#")]),o._v(" spring循环依赖解决方式")]),o._v(" "),e("p",[e("strong",[o._v("核心")]),o._v("：三级缓存")]),o._v(" "),e("p",[e("strong",[o._v("核心对象")]),o._v("：")]),o._v(" "),e("p",[e("code",[o._v("SingletonObjects")]),o._v("： 单例缓存池 里面存放的是完整的对象")]),o._v(" "),e("p",[e("code",[o._v("EarlySingletonObjects")]),o._v("：  创建中的bean的缓存(提前曝光)")]),o._v(" "),e("p",[e("code",[o._v("SingletonFactories")]),o._v("：  Map<String, ObjectFactory<?>> 对象工厂")]),o._v(" "),e("p",[e("strong",[o._v("流程")]),o._v("：")]),o._v(" "),e("p",[o._v("1.先在一级缓存查找")]),o._v(" "),e("p",[o._v("2.一级缓存没有去二级缓存查询")]),o._v(" "),e("p",[o._v("3.二级缓存没有去三级缓存获取对象工厂，在通过工厂的getObject()创建，此时创建是还没有属性注入的")]),o._v(" "),e("p",[o._v("4.然后把创建的对象放到缓存中提前曝光")]),o._v(" "),e("p",[o._v("5.完成属性赋值后创建完成再从二级缓存放到一级缓存中，后续获取的就是完整对象")]),o._v(" "),e("p",[e("strong",[o._v("举例")]),o._v("：A->B  B->A")]),o._v(" "),e("p",[o._v("在一级缓存中找A，没有去二级缓存，也没有，去三级缓存获取并放到二级缓存中提前曝光A，然后对属性B注入")]),o._v(" "),e("p",[o._v("在一级缓存中找B，没有去二级缓存，也没有，去三级缓存获取并放到二级缓存中提前曝光B，然后B中的属性A注入，一级缓存没有，去二级缓存查找，二级缓存中有提前曝光的A，所以能从二级缓存中获取到A，然后注入，B完成创建就会放到一级缓存中，然后方法返回B回到A的属性注入，给A注入B，此时A也完成创建放入一级缓存，从而解决循环依赖。")]),o._v(" "),e("p",[e("strong",[o._v("备注")]),o._v("：三级缓存不能解决【构造注入的循环依赖】和【prototype  field属性注入循环依赖】")])])}),[],!1,null,null,null);e.default=r.exports}}]);