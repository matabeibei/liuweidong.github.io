<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java基础 | liuweidong&#39; blogs</title>
    <meta name="description" content=" ">
    <link rel="icon" href="/icon.png">
    
    <link rel="preload" href="/assets/css/0.styles.6aaa91c1.css" as="style"><link rel="preload" href="/assets/js/app.cac31f9e.js" as="script"><link rel="preload" href="/assets/js/7.ac0035c6.js" as="script"><link rel="prefetch" href="/assets/js/10.05f7d4d0.js"><link rel="prefetch" href="/assets/js/2.854dcf62.js"><link rel="prefetch" href="/assets/js/3.0b48a09e.js"><link rel="prefetch" href="/assets/js/4.b1797d2e.js"><link rel="prefetch" href="/assets/js/5.18020b59.js"><link rel="prefetch" href="/assets/js/6.4613e240.js"><link rel="prefetch" href="/assets/js/8.cd518d36.js"><link rel="prefetch" href="/assets/js/9.68fde8b7.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6aaa91c1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">liuweidong' blogs</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">关于我</a></div><div class="nav-item"><a href="/blogs/" class="nav-link router-link-active">博客</a></div><div class="nav-item"><a href="/reading-notes/" class="nav-link">读书笔记</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">关于我</a></div><div class="nav-item"><a href="/blogs/" class="nav-link router-link-active">博客</a></div><div class="nav-item"><a href="/reading-notes/" class="nav-link">读书笔记</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blogs/java_basic.html" aria-current="page" class="active sidebar-link">Java基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blogs/java_basic.html#java值传递" class="sidebar-link">Java值传递</a></li><li class="sidebar-sub-header"><a href="/blogs/java_basic.html#hashmap" class="sidebar-link">Hashmap</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blogs/java_basic.html#结构" class="sidebar-link">结构</a></li><li class="sidebar-sub-header"><a href="/blogs/java_basic.html#put流程：" class="sidebar-link">put流程：</a></li><li class="sidebar-sub-header"><a href="/blogs/java_basic.html#hashmap红黑树比较细节：" class="sidebar-link">Hashmap红黑树比较细节：</a></li><li class="sidebar-sub-header"><a href="/blogs/java_basic.html#hashmap的hash-函数为什么使用key的hashcode与低16位做异或？" class="sidebar-link">Hashmap的hash()函数为什么使用key的hashcode与低16位做异或？</a></li><li class="sidebar-sub-header"><a href="/blogs/java_basic.html#rehash流程：" class="sidebar-link">rehash流程：</a></li></ul></li><li class="sidebar-sub-header"><a href="/blogs/java_basic.html#concurrenthashmap" class="sidebar-link">ConcurrentHashmap</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blogs/java_basic.html#加锁机制" class="sidebar-link">加锁机制</a></li><li class="sidebar-sub-header"><a href="/blogs/java_basic.html#size计算方式" class="sidebar-link">Size计算方式</a></li><li class="sidebar-sub-header"><a href="/blogs/java_basic.html#_1-8的put流程" class="sidebar-link">1.8的put流程</a></li></ul></li><li class="sidebar-sub-header"><a href="/blogs/java_basic.html#threadlocal" class="sidebar-link">Threadlocal</a></li></ul></li><li><a href="/blogs/blog2.html" class="sidebar-link">blog2</a></li><li><a href="/blogs/blog3.html" class="sidebar-link">blog3</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="java基础"><a href="#java基础" class="header-anchor">#</a> Java基础</h1> <h2 id="java值传递"><a href="#java值传递" class="header-anchor">#</a> Java值传递</h2> <p>基本数据类型是值传递，对象是共享对象传递，可以理解为值传递的特例，是把对象的地址值拷贝了一份，再传递，所以如果像String这种对象，字符串是不可变的，修改之后是一个新的String，传递的是原来对象的地址拷贝副本，新创建对象后副本指向了新对象，所以不会影响原来的对象（即出了方法之后就失效了）。</p> <h2 id="hashmap"><a href="#hashmap" class="header-anchor">#</a> Hashmap</h2> <h3 id="结构"><a href="#结构" class="header-anchor">#</a> 结构</h3> <p>1.7是数组+链表，1.8是数组+链表/红黑树，1.7前插法并发情况下扩容会导致循环链表</p> <p>扩容机制：</p> <p>capacity 即容量，默认16。</p> <p>loadFactor 加载因子，默认是0.75。</p> <p>threshold 阈值。阈值=容量*加载因子。默认12。当元素数量超过阈值时便会触发扩容(X2)。</p> <h3 id="put流程："><a href="#put流程：" class="header-anchor">#</a> put流程：</h3> <p>1.先判断当前node[]是否为空，为空就初始化node[]，默认初始化长度为16；</p> <p>2.根据key的hash值与node[].size() -1 做&amp;操作，计算出key应该放在node[]数组的index；</p> <p>3.如果该位置为null，则把key-value设置在该位置的node[]元素；</p> <p>4.如果该位置不为null，则判断该位置的上是否红黑树，是红黑树按照红黑树的方式遍历在树上找有没有对应的key，有就更新，没有就在树上添加key-value；</p> <p>5.如果该位置不是红黑树，则对该位置按照链表的方式查找有没有对应key，有就更新没有就添加，添加完之后如果链表长度大于8就转为红黑树，ps：转红黑树的方法里面会判断map的元素个数小于64，则不会转红黑树，通过rehash进行扩容；</p> <p>6.如果是添加元素的话，最后添加完如果map的元素个数超过阈值也会进行rehash扩容。</p> <h3 id="hashmap红黑树比较细节："><a href="#hashmap红黑树比较细节：" class="header-anchor">#</a> Hashmap红黑树比较细节：</h3> <p>当数组对应位置为红黑树时，对红黑树上的key进行比较，出现hashcode一样，equal不一样的情况，会判断这个key有没有使用Comparable接口，如果没有使用Comparable的话会遍历整棵树，还没有相等使用System.identityHashCode，查询会退化到O(n)，所以使用Comparable（在实现了的情况）会是流程简化很多，提升性能，但是如果Comparable比较也返回相同还是会遍历整棵数，还没有再调用System.identityHashCode 比较，这个要注意。所以总的来说，转为红黑之后，key实现了Comparable接口能提升插入和删除的操作性能，而这个性能的提升是基于大数据量的情况下的，链表的元素个数比较少，提升不明显，所以在转红黑树之后多增加了Comparable（实现了的话）的比较。</p> <ul><li>ps：没有实现Comparable或Comparable比较相同的话，会调用System.identityHashCode打破平衡的，返回只能是左或右，确定下次循环是往左还是右，一直找到叶子上面，进行添加元素。</li></ul> <h3 id="hashmap的hash-函数为什么使用key的hashcode与低16位做异或？"><a href="#hashmap的hash-函数为什么使用key的hashcode与低16位做异或？" class="header-anchor">#</a> Hashmap的hash()函数为什么使用key的hashcode与低16位做异或？</h3> <p>做异或是扰动函数，混合原hash值的高位和低位，加大低16位的随机性，要加强低16位随机性是因为计算数组index是跟数组长度-1做&amp;操作，数组长度有限，用不到hashcode的高位，所以使用扰动函数增加低位随机性，减少hash碰撞。</p> <h3 id="rehash流程："><a href="#rehash流程：" class="header-anchor">#</a> rehash流程：</h3> <p>1.如果旧容量大于0，则判断有没有到元素个数最大值(2^30)，到了就不扩容了，否则就扩容为之前的2倍；</p> <p>2.如果旧容量不大于0，则初始化容量为默认的16；</p> <p>3.然后通过新容量和负载因子计算新阈值；</p> <p>4.对旧node[]上面的元素进行重新散列放到新扩容的node[]上，并替换旧node[]；</p> <h2 id="concurrenthashmap"><a href="#concurrenthashmap" class="header-anchor">#</a> ConcurrentHashmap</h2> <h3 id="加锁机制"><a href="#加锁机制" class="header-anchor">#</a> 加锁机制</h3> <p>//TODO</p> <h3 id="size计算方式"><a href="#size计算方式" class="header-anchor">#</a> Size计算方式</h3> <p>jdk1.8推荐用mappingCount(),因为size()里面会判断是否超过int的最大值，超过则返回int最大值；</p> <p>1.7是先不加锁计算三次，如果一样就返回，不一样再加锁计算；</p> <p>1.8是通过baseCount和CounterCell累加计算，没有竞争的情况下cas给baseCount+1，出现竞争，竞争失败的线程会去CounterCell[]中获取一个元素，如果为null就创建一个CounterCell，一般给里面的value设置为1，放入到CounterCell[]中，不为null就给value进行cas加1，最后计算size的时候累加。</p> <ul><li>原因：ConcurrentHashMap是采用CounterCell数组来记录元素个数的，像一般的集合记录集合大小，直接定义一个size的成员变量即可，当出现改变的时候只要更新这个变量就行。为什么ConcurrentHashMap要用这种形式来处理呢？ 问题还是处在并发上，ConcurrentHashMap是并发集合，如果用一个成员变量来统计元素个数的话，为了保证并发情况下共享变量的的安全，势必会需要通过加锁或者自旋来实现，如果竞争比较激烈的情况下，size的设置上会出现比较大的冲突反而影响了性能，所以在ConcurrentHashMap采用了分片的方法来记录大小</li></ul> <h3 id="_1-8的put流程"><a href="#_1-8的put流程" class="header-anchor">#</a> 1.8的put流程</h3> <ul><li>核心：为null cas，hash冲突锁住首节点</li></ul> <p>1.key-value判空，有一个为空报空指针；</p> <p>2.死循环遍历node[]，如果node[]为空则进行初始化；</p> <p>3.对key进行散列（方式和Hashmap一样），找到node[]中对应位置，如果该位置为null，则使用cas方式设置值，设置失败重新循环；</p> <p>4.如果对应位置有元素了，则用syn锁住头节点，对该位置进行遍历，如果是链表就以链表方式进行查找，有就更新，没有就添加；</p> <p>5.如果是红黑树，就用红黑树的方式的进行查找设置值；</p> <p>6.结束之后判断链表长度是否大于8，则转成红黑树（也会和Hashmap一样判断元素是否到达64，没到达的话就resize）；</p> <p>7.添加count。</p> <h2 id="threadlocal"><a href="#threadlocal" class="header-anchor">#</a> Threadlocal</h2> <p>threadlocal里面有个内部类threadlocalmap，每个thread里面都维护了一个threadlocalmap，从本质上来讲就是每个线程有一个map，这个map的key就是当前这个threadlocal，value就是我们设置进去的值，每次get的时候都是从自己的threadlocalmap里面取值，所以不存在线程安全问题，总体来说threadlocal只是充当一个这个map的key的作用，并给每个线程提供一个threadlocalmap的初始值。</p></div> <div class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">4/23/2022, 2:42:11 PM</span></div></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/blogs/blog2.html">
          blog2
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.cac31f9e.js" defer></script><script src="/assets/js/7.ac0035c6.js" defer></script>
  </body>
</html>
