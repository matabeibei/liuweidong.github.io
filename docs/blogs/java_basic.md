# Java基础

## Java值传递
基本数据类型是值传递，对象是共享对象传递，可以理解为值传递的特例，是把对象的地址值拷贝了一份，再传递，所以如果像String这种对象，字符串是不可变的，修改之后是一个新的String，传递的是原来对象的地址拷贝副本，新创建对象后副本指向了新对象，所以不会影响原来的对象（即出了方法之后就失效了）。

## Hashmap
### 结构
1.7是数组+链表，1.8是数组+链表/红黑树，1.7前插法并发情况下扩容会导致循环链表

扩容机制：

capacity 即容量，默认16。

loadFactor 加载因子，默认是0.75。

threshold 阈值。阈值=容量*加载因子。默认12。当元素数量超过阈值时便会触发扩容(X2)。

### put流程：
1.先判断当前node[]是否为空，为空就初始化node[]，默认初始化长度为16；

2.根据key的hash值与node[].size() -1 做&操作，计算出key应该放在node[]数组的index；

3.如果该位置为null，则把key-value设置在该位置的node[]元素；

4.如果该位置不为null，则判断该位置的上是否红黑树，是红黑树按照红黑树的方式遍历在树上找有没有对应的key，有就更新，没有就在树上添加key-value；

5.如果该位置不是红黑树，则对该位置按照链表的方式查找有没有对应key，有就更新没有就添加，添加完之后如果链表长度大于8就转为红黑树，ps：转红黑树的方法里面会判断map的元素个数小于64，则不会转红黑树，通过rehash进行扩容；

6.如果是添加元素的话，最后添加完如果map的元素个数超过阈值也会进行rehash扩容。

### Hashmap红黑树比较细节：
当数组对应位置为红黑树时，对红黑树上的key进行比较，出现hashcode一样，equal不一样的情况，会判断这个key有没有使用Comparable接口，如果没有使用Comparable的话会遍历整棵树，还没有相等使用System.identityHashCode，查询会退化到O(n)，所以使用Comparable（在实现了的情况）会是流程简化很多，提升性能，但是如果Comparable比较也返回相同还是会遍历整棵数，还没有再调用System.identityHashCode 比较，这个要注意。所以总的来说，转为红黑之后，key实现了Comparable接口能提升插入和删除的操作性能，而这个性能的提升是基于大数据量的情况下的，链表的元素个数比较少，提升不明显，所以在转红黑树之后多增加了Comparable（实现了的话）的比较。

- ps：没有实现Comparable或Comparable比较相同的话，会调用System.identityHashCode打破平衡的，返回只能是左或右，确定下次循环是往左还是右，一直找到叶子上面，进行添加元素。

### Hashmap的hash()函数为什么使用key的hashcode与低16位做异或？
做异或是扰动函数，混合原hash值的高位和低位，加大低16位的随机性，要加强低16位随机性是因为计算数组index是跟数组长度-1做&操作，数组长度有限，用不到hashcode的高位，所以使用扰动函数增加低位随机性，减少hash碰撞。

### rehash流程：
1.如果旧容量大于0，则判断有没有到元素个数最大值(2^30)，到了就不扩容了，否则就扩容为之前的2倍；

2.如果旧容量不大于0，则初始化容量为默认的16；

3.然后通过新容量和负载因子计算新阈值；

4.对旧node[]上面的元素进行重新散列放到新扩容的node[]上，并替换旧node[]；

## ConcurrentHashmap

### 加锁机制 
//TODO 

### Size计算方式
jdk1.8推荐用mappingCount(),因为size()里面会判断是否超过int的最大值，超过则返回int最大值；

1.7是先不加锁计算三次，如果一样就返回，不一样再加锁计算；

1.8是通过baseCount和CounterCell累加计算，没有竞争的情况下cas给baseCount+1，出现竞争，竞争失败的线程会去CounterCell[]中获取一个元素，如果为null就创建一个CounterCell，一般给里面的value设置为1，放入到CounterCell[]中，不为null就给value进行cas加1，最后计算size的时候累加。

- 原因：ConcurrentHashMap是采用CounterCell数组来记录元素个数的，像一般的集合记录集合大小，直接定义一个size的成员变量即可，当出现改变的时候只要更新这个变量就行。为什么ConcurrentHashMap要用这种形式来处理呢？ 问题还是处在并发上，ConcurrentHashMap是并发集合，如果用一个成员变量来统计元素个数的话，为了保证并发情况下共享变量的的安全，势必会需要通过加锁或者自旋来实现，如果竞争比较激烈的情况下，size的设置上会出现比较大的冲突反而影响了性能，所以在ConcurrentHashMap采用了分片的方法来记录大小

### 1.8的put流程
- 核心：为null cas，hash冲突锁住首节点

1.key-value判空，有一个为空报空指针；

2.死循环遍历node[]，如果node[]为空则进行初始化；

3.对key进行散列（方式和Hashmap一样），找到node[]中对应位置，如果该位置为null，则使用cas方式设置值，设置失败重新循环；

4.如果对应位置有元素了，则用syn锁住头节点，对该位置进行遍历，如果是链表就以链表方式进行查找，有就更新，没有就添加；

5.如果是红黑树，就用红黑树的方式的进行查找设置值；

6.结束之后判断链表长度是否大于8，则转成红黑树（也会和Hashmap一样判断元素是否到达64，没到达的话就resize）；

7.添加count。

## Threadlocal
threadlocal里面有个内部类threadlocalmap，每个thread里面都维护了一个threadlocalmap，从本质上来讲就是每个线程有一个map，这个map的key就是当前这个threadlocal，value就是我们设置进去的值，每次get的时候都是从自己的threadlocalmap里面取值，所以不存在线程安全问题，总体来说threadlocal只是充当一个这个map的key的作用，并给每个线程提供一个threadlocalmap的初始值。

## Java线程池

### 参数
corePoolSize：核心线程数量

maximumPoolSize: 线程池的最大线程数

keepAliveTime: 空闲线程存活时间

unit: keepAliveTime的时间单位，分钟、秒等

workQueue: 线程工作队列，阻塞队列，线程池从这个队列中取线程

handler: 拒绝策略，线程数量达到maximumPoolSize时的策略，默认提供了4种

threadFactory: 创建线程时使用的工厂，可以对线程进行统一设置，如是否守护线程、线程名等

### 4种工作队列
ArrayBlockingQueue：有界阻塞队列，当线程数量n：corePoolSize <= n < maximumPoolSize 且 n >= capacity :创建新线程处理任务 当：n >= maximumPoolSize 且 n >= capacity 拒绝线程

LinkedBlockingQueue: 无界队列，maximumPoolSize不起作用，会一直创建线程

SynchronousQuene: 不缓存任务，直接调度执行，线程数超过 maximumPoolSize 则直接拒绝线程

PriorityBlockingQueue: 带优先级的线程队列

### 4种拒绝策略
AbortPolicy: 直接丢弃并抛出异常

CallerRunsPolicy: 线程池没有关闭则直接调用线程的run方法

DiscardPolicy: 直接丢弃任务

DiscardOldestPolicy: 丢弃最早的任务，并尝试把当前任务加入队列

### 线程池添加任务流程：execute()和addWorker()
addWorker()方法有两个参数，第一个是提交的任务，第二个是boolean，true比较核心线程数，false比较最大线程数，没超过就会创建新线程执行任务

1.判断线程数小于核心线程数，调用addWorker()创建线程执行任务

2.超过核心线程数，放入工作队列中

3.工作队列满了，没到最大线程数继续创建线程执行任务

### 线程池的状态
running:线程池刚创建就是running状态

shutdown：调用showdown进入该状态，不会继续接受新任务，会处理已添加的任务

stop:调用shutdownnow进入该状态，不会继续接受新任务，也不会处理已添加的任务，而且中断正在执行的任务

tidying：当全部任务已终止，任务数量为0，进入该状态，会调用钩子函数terminated()

terminated：执行完钩子函数terminated()之后进入该状态，线程池彻底终止

### 怎么优雅的结束线程池任务？

结束线程池有shutdown和shutdownnow两个方法

shutdown：会让线程池进入shutdown状态，线程池不再接受新任务，然后线程池中的任务执行完才关闭，即使线程池中的线程在执行的任务处理阻塞状态，线程也不会关闭，会执行完(因为通过worker的锁只关闭空闲的线程)，所以使用shutdown关闭线程池要保证线程池中的任务不会一直处于阻塞状态。

shutdownnow：会让线程进入stop状态，线程池不再接受新任务，处于队列中的任务不再执行，正在执行任务的线程如果因任务处于阻塞状态，会报异常，否则会继续执行(因为interrupt只是设置线程中断标志，什么时候终止由线程自生决定)，所以调用shutdownnow可能会报异常，一定要对任务里进行异常捕获。

另外两个方法调用完之后不会里面关闭线程池，如果需要等待线程池关闭才执行后续逻辑，需要调用awaitTermination等待关闭。

## Synchonized 
Synchonized：悲观锁，重量级锁，锁方法使用对象实例，锁静态方法是用类对象，锁代码块是根据传入的参数，作用于代码块用的monitorenter和monitorexit指令，作用于方法使用acc_Synchonized标志，不管哪种都是方式其实都是基于objMonitor的，每个对象都有一个objMonitor，保存在对象头中，对象结构：对象头、实例数据、对齐填充，对象头：mark word 和 classMetadataAddress，markword：monitor指针、标志位10。

### monitor对象结构
count owner entrylist waitset，notify和notifyall唤醒waitset 释放锁唤醒entrylist

### 锁升级
无锁：当一个对象被创建之后，还没有线程进入，这个时候对象处于无锁状态

偏向锁：目的 一个线程拿锁后，下次这个线程不用加锁和解锁，过程：获取偏向锁时会在markword中记录偏向线程的id，重入时只需要比较id即可，如果另外一个线程来获取偏向锁，发现线程id不一样，就会去判断偏向的线程是不是已死亡或者以退出同步块，是的话就设置为无锁，其他线程可以通过竞争设置为偏向锁，如果还在同步块，则暂停偏向线程，升级为轻量级锁

轻量级锁：目的：竞争者不多，减少重量级锁的用户态和内核态切换，过程：获取时会把markword复制到lockrecord中（displacedmarkword），然后用cas把dis替换markword，成功就获取锁，失败就自旋，自旋到一定次数就会升级为重量级锁（自适应自旋）

重量级锁：为获取锁的线程回进入阻塞队列，涉及到用户态和内核态的切换

## cas：
unsafe类，里面保存对象value字段的内存偏移量，通过偏移量就可以找到原值，把原值和预期值比较，相等就修改为新值，底层基于cpu指令cmpxchg

## volatile
保证可见性，不保证原子性，禁止指令重排序，例：atomic类

### 可见性
一个线程操作共享变量，会去主存中读取数据到自己的工作内存，然后进行操作，操作完马上刷回主存，并设置其他cpu工作内存中这个共享变量的缓存无效，其他cpu需要这个共享变量会去主存中读取，保证了可见性。

### 不保证原子性
像并发情况下，对int i做加一操作，整个操作分为三部分，先从主存读取值，然后加一，再刷回主存，这里这三个原子性操作，比如：A线程从主存获取值为0，然后B获取到cpu执行权，也从主存中获取值为0，然后加一刷回主存，又到A执行，这时因为A已经从内存中读取值了，不会再去读取直接加一刷回主存，就出现了数据问题。

### 禁止指令重排序
在cpu执行字节码指令的时候，并不一定会按照代码顺序去执行，会对指令进行重排序优化cpu的执行效率，且保证在单线程情况下重排序后的指令执行结果跟重排序之前的执行结果一致。但是在多线程的情况下重排序之后的执行结果就不能保证了，使用该关键字可以禁止指令重排序。

### 原理
其实底层是使用的内存屏障，从字节码上看被volatile修饰的变量在编译成字节码文件时会多个lock指令，在读取数据之前会加入读屏障，缓存失效会去主存读取，在写完数据之后加入写屏障，写完数据之后马上刷回主存，并且禁止了指令重排序，屏障之前的指令不会排到屏障之后。

### 内存屏障的作用：
1.在有内存屏障的地方，会禁止指令重排序，即屏障下面的代码不能跟屏障上面的代码交换执行顺序。

2.在有内存屏障的地方，线程修改完共享变量以后会马上把该变量从本地内存写回到主内存，并且让其他线程本地内存中该变量副本失效（使用MESI协议）

另外注意在单例双检锁的时候要加volatile修饰，禁止指令重排，防止拿到空对象之后使用异常。

## java内存模型（JMM）
JMM是一种规范，定义这个规范只要是为了屏蔽操作系统和硬件差异，在jvm中，对象存储在堆中，每个线程都有自己的栈内存，jmm从抽象的角度定义了线程和主内存的关系，线程的共享变量存储在主内存中，每个线程都有自己的工作内存，当两个线程要通信时，线程A在自己的工作内存中更新完共享变量后刷到主存中，线程B再去主存中获取这个这个共享变量并拷贝一个变量副本到自己的工作内存中使用。这就在多线程并发的情况下就会有一个共享变量的可见性问题，一个线程修改了共享变量没有及时刷到主存中，这时候这个修改对其他线程来说就是不可能见的，可以使用volatile和同步来解决这个问题。volatile是使用缓存一致性协议(MESI)来保证可见性的，核心思想就是当一个cpu修改了工作内存中的共享变量之后会马上刷到主存中，并且通知其他cpu设置工作内存中的该共享变量为无效状态，当其他cpu要读取这个变量时会去主存中重新读取。

## JUC的cas和aqs、ReentrantLock
### ReentrantLock
是基于aqs框架，aqs核心：cas、state、fifo队列，aqs通过修改state获取锁和释放锁，面对多线程竞争，获取锁失败的线程会放入到队列中等待再次竞争获取锁

### JUC
volatile state + cas + fifo:用修改state的值是否成功来获取锁，volatile保证state的可见性，cas保证修改的原子性，用fifo存储获取锁失败需要阻塞的线程，在释放锁时从fifo中唤醒线程 
aqs和syn的主要区别就在于是实现方式不一样，aqs是jdk实现的，syn是jvm实现的，优化前syn的性能比较差，优化后差不多，但是aqs的具体实更加丰富，比如指定唤醒、公平锁这种